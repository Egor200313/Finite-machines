## Описание алгоритма
По регулярному выражению строим детерминированный автомат
1. Для этого строим дерево разбора регулярки (RegexParseTree)
   Вершинами дерева являются символы из регулярки
   
   Для каждой вершины считаем 3 функции:
   1. `first_pos` - позиции из исходной регулярки, на которые может начинаться слово 
   лежащее в языке задаваемом поддеревом с корнем в текущей вершине
   2. `last_pos` - аналогично только для окончаний
   3. `nullable` - флаг говорящий лежит ли пустое слово в языке
   задаваемом поддеревом текущей вершины
   
   При __конкатенации__ `first_pos` равен `first_pos` левого операнда
   и если левый операнд `nullable` то объединению `first_pos`
   левого и правого, что следует из определения конкатенации
   
   При __объедеинении__ `first_pos` равен объединению `first_pos`
   левого и правого, что следует из определения объединения
   
   При __итерации__ `first_pos` не изменяется
   
   Аналогично выполняется подсчет `last_pos`.
   
   `nullable` становится `True` когда приходит операция итерации, 
   так как теперь пустое слово содержится в языке задаваемом поддеревом.
   
   Также `nullable` при объединении равен дизъюнкции `nullable` операндов,
   а при конкатенации конъюнкции.
   
2. Для каждого буквеннного символа считаем `follow_pos` - 
   множество позиций/букв которые могут следовать за ним
   Делаем пересчет на операциях конкатенации (добавляем к `follow_pos` каждого символа из возможных окончаний левого операнда
   все начала из правого операнда, что согласуется с определением конкатенации) и
   итерации (говорим что за каждым символом из окончания может следовать символ из начала)
   
3. Строим автомат по массиву `follow_pos`
   Множествам позиций будем сопоставлять состояния
   Стартовое состояние это корень дерева, т.е. последний элемент массива `tree`
   Далее получаем переход по каждой букве объединяя `fllow_pos` от тех позиций в текущем состоянии, которым соответствует эта буква
   Когда все состояния обработаны, завершаем работу
   Конечными будут те состояния в множестве позиций которых есть терминальный символ `#`
   В результате получаем ДКА по регулярному выражению
   
**Решение задачи 15**
После того, как построен автомат, задача поиска максимального префикса, принадлежащего
как языку регулярки, так и данному слову, становится тривиальной
Необходимо пройтись по символам данного слова и вывести наибольшую позицию,
в которой мы приходим в завершающее состояние